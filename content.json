{"meta":{"title":"Nate Personal Blog","subtitle":"","description":"","author":"John Doe","url":"https://github.com/eagle230/nate.github.io","root":"/nate.github.io/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-22T02:06:37.589Z","updated":"2020-12-21T11:48:52.360Z","comments":false,"path":"/404.html","permalink":"https://github.com/eagle230/nate.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-12-22T02:36:44.756Z","updated":"2020-12-21T11:48:52.360Z","comments":false,"path":"about/index.html","permalink":"https://github.com/eagle230/nate.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-12-22T02:02:46.813Z","updated":"2020-12-21T11:48:52.360Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/eagle230/nate.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-22T02:15:09.045Z","updated":"2020-12-22T02:15:09.045Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/eagle230/nate.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-22T02:06:37.592Z","updated":"2020-12-21T11:48:52.360Z","comments":false,"path":"repository/index.html","permalink":"https://github.com/eagle230/nate.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"DMA + IDLE中断实现接收不定长数据","slug":"STM32 IDLE + DMA","date":"2020-12-28T11:49:41.910Z","updated":"2020-12-28T11:56:23.140Z","comments":true,"path":"2020/12/28/STM32 IDLE + DMA/","link":"","permalink":"https://github.com/eagle230/nate.github.io/2020/12/28/STM32%20IDLE%20+%20DMA/","excerpt":"","text":"DMA + IDLE中断实现接收不定长数据一、实现原理将串口使能空闲中断并且开启DMA接收（会定义一个数组，这个数组的长度是接收不定长的最大长度），这时候如果当串口产生了中断，判断是否是空闲中断，如果是空闲中断就将计算DMA接收了多少个字节，然后将数据进行处理。一帧接收完成。 二、实现步骤步骤1.初始化串口，使能空闲中断。步骤2.初始化串口的DMA接收，并且开启DMA。步骤3.编写UART中断服务函数。 三、相关代码初始化123456789101112131415161718192021222324252627282930313233343536/** * @brief USART2 Initialization Function * @param None * @retval None */static void MX_USART2_UART_Init(void)&#123; /* USER CODE BEGIN USART2_Init 0 */ /* USER CODE END USART2_Init 0 */ /* USER CODE BEGIN USART2_Init 1 */ /* USER CODE END USART2_Init 1 */ huart2.Instance = USART2; huart2.Init.BaudRate = 19200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&amp;huart2) != HAL_OK) &#123; Error_Handler(); &#125; /* USER CODE BEGIN USART2_Init 2 */ HAL_UART_Receive_DMA(&amp;huart2,&amp;RxBuff[0],RX_BUFFER_LEN); /*启动DMA接收，如果不初始化第一帧会丢掉*/ __HAL_UART_ENABLE_IT(&amp;huart2,UART_IT_IDLE); /*使能空闲中断*/ /* USER CODE END USART2_Init 2 */&#125; 中断服务函数增加自己的处理函数123456789101112131415/** * @brief This function handles USART2 global interrupt. */void USART2_IRQHandler(void)&#123; /* USER CODE BEGIN USART2_IRQn 0 */ /* USER CODE END USART2_IRQn 0 */ HAL_UART_IRQHandler(&amp;huart2); /* USER CODE BEGIN USART2_IRQn 1 */ UART_IDLE_IRQHandler(&amp;huart2); /*用户自定义的空闲中断处理函数*/ /* USER CODE END USART2_IRQn 1 */&#125; 编写的接收不定长函数123456789101112131415161718/* DMA+串口空闲中断接收不定长*/void UART_IDLE_IRQHandler(UART_HandleTypeDef *huart)&#123; if(huart-&gt;Instance == USART2) //判断是否是串口2 &#123; if(RESET != __HAL_UART_GET_FLAG(&amp;huart2, UART_FLAG_IDLE)) //判断是否是空闲中断 &#123; __HAL_UART_CLEAR_IDLEFLAG(&amp;huart2); //清楚空闲中断标志 HAL_UART_DMAStop(&amp;huart2); RxLen = (RX_BUFFER_LEN - __HAL_DMA_GET_COUNTER(&amp;hdma_usart2_rx)); HAL_UART_Transmit(&amp;huart3,(uint8_t*)&amp;RxBuff,RxLen, 5000); HAL_UART_Receive_DMA(&amp;huart2,&amp;RxBuff[0],RX_BUFFER_LEN); RxLen = 0; &#125; &#125;&#125; 重定向printf到uart12345678/* 重定向printf*/int fputc(int ch, FILE* stream)&#123; HAL_UART_Transmit(&amp;huart2,(uint8_t*)&amp;ch, 1, 5000); return ch;&#125;","categories":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/categories/C-Lib/"}],"tags":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/tags/C-Lib/"}]},{"title":"GNRMC定位信息的读取与解析","slug":"GNRMC Parser","date":"2020-12-28T11:45:09.531Z","updated":"2020-12-28T12:05:59.957Z","comments":true,"path":"2020/12/28/GNRMC Parser/","link":"","permalink":"https://github.com/eagle230/nate.github.io/2020/12/28/GNRMC%20Parser/","excerpt":"","text":"GNRMC定位信息的读取与解析格 式： 12$GPRMC,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,&lt;10&gt;,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50 说 明： 字段 0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息字段 1：UTC时间，hhmmss.sss格式字段 2：状态，A=定位，V=未定位字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0）字段 4：纬度N（北纬）或S（南纬）字段 5：经度dddmm.mmmm，度分格式（前导位数不足则补0）字段 6：经度E（东经）或W（西经）字段 7：速度，节，Knots（一节也是1.852千米／小时）字段 8：方位角，度（二维方向指向，相当于二维罗盘）字段 9：UTC日期，DDMMYY格式字段10：磁偏角，（000 - 180）度（前导位数不足则补0）字段11：磁偏角方向，E=东，W=西字段12：模式，A=自动，D=差分，E=估测，N=数据无效（3.0协议内容）字段13：校验值， 这里，“ * ”为校验和识别符，其后面的两位数为校验和代表了“$”和“*”之间所有字符（不包括这两个字符）的异或值的十六进制值 结构体定义： 1234567891011121314151617181920212223242526272829typedef struct &#123; int year; int mounth; int day;&#125; data_struct;typedef struct&#123; int hour; int minute; int second; int milliSecond;&#125; time_struct;typedef struct&#123; data_struct utcDate; time_struct utcTime; float lat; //纬度 float lon; //经度 float speed; float direction; float declination; char ew; char ns; char status; char declin_ew; char mode;&#125; gps_gprmc_struct; GPS输出格式： 12345678910/*GPS数据如下$GPGGA,121252.000,3937.3032,N,11611.6046,E,1,05,2.0,45.9,M,-5.7,M,,0000*77 $GPRMC,121252.000,A,3958.3032,N,11629.6046,E,15.15,359.95,070306,,,A*54 $GPVTG,359.95,T,,M,15.15,N,28.0,K,A*04 $GPGGA,121253.000,3937.3090,N,11611.6057,E,1,06,1.2,44.6,M,-5.7,M,,0000*72 $GPGSA,A,3,14,15,05,22,18,26,,,,,,,2.1,1.2,1.7*3D $GPGSV,3,1,10,18,84,067,23,09,67,067,27,22,49,312,28,15,47,231,30*70 $GPGSV,3,2,10,21,32,199,23,14,25,272,24,05,21,140,32,26,14,070,20*7E $GPGSV,3,3,10,29,07,074,,30,07,163,28*7D*/ 经纬度转换公式： 123456$GPRMC,121252.000,A,3958.3032,N,11629.6046,E,15.15,359.95,070306,,,A*54 lat = 3958.3032; ddmm.mmmm 度分格式lon = 11629.6046; dddmm.mmmm 度分格式度分格式转换成度格式dd.ddddd 1度=60分3958.3032 取出mm.mmmm 也就是58.3032，转换成度 58.3032/60 = 0.97172 ，最后等于39.97172 11629.6046取出mm.mmmm 也就是29.6046，转换成度 29.6046/60 = 0.49341 ，最后等于116.49341 解析函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243int GPS_Parse(void)&#123; uint16_t grmc_len; int ret = false; uint8_t ret_crc = 0,ret_sscanf = 0; char* p_grmc; NRF_LOG_INFO(&quot;gps.gps_info.BuffIndex:%d\\r\\n&quot;,gps.gps_info.BuffIndex);// NRF_LOG_INFO(&quot;GPS_recv : %s\\r\\n&quot;,gps.gps_info.UartBuff); if ((p_grmc = strstr((char*)&amp;gps.gps_info.UartBuff[0], &quot;$GNRMC&quot;)) != NULL) &#123; for (grmc_len = 0; grmc_len&lt;strlen(p_grmc); grmc_len++) &#123; if (p_grmc[grmc_len] == &#x27;\\r&#x27;) &#123; p_grmc[grmc_len] = &#x27;\\0&#x27;; //replace ‘/n’ with null break; &#125; &#125; NRF_LOG_INFO(&quot;grmc_len: %d\\r\\n&quot;,grmc_len); NRF_LOG_INFO(&quot;GPS_Parse : %s\\r\\n&quot;,p_grmc); ret_crc = GpsFrameCheck(p_grmc,grmc_len);///帧校验 if(ret_crc == true) &#123; memset(&amp;gps.gprmc, 0, sizeof(gps_gprmc_struct)); ret_sscanf = sscanf (p_grmc, &quot;$GNRMC,%2d%2d%2d.%3d,%c,%f,%c,%f,%c,%f,%f,%2d%2d%2d,%f,%c,%c*&quot;, \\ &amp; gps.gprmc.utcTime.hour, &amp; gps.gprmc.utcTime.minute, &amp; gps.gprmc.utcTime.second, &amp; gps.gprmc.utcTime.milliSecond, \\ &amp; gps.gprmc.status, &amp; gps.gprmc.lat, &amp; gps.gprmc.ns, &amp; gps.gprmc.lon, &amp; gps.gprmc.ew, &amp; gps.gprmc.speed, &amp; gps.gprmc.direction, \\ &amp; gps.gprmc.utcDate.day, &amp; gps.gprmc.utcDate.mounth, &amp; gps.gprmc.utcDate.year, &amp; gps.gprmc.declination, &amp;gps.gprmc.declin_ew, &amp; gps.gprmc.mode); NRF_LOG_INFO(&quot;gps.gprmc.lat = %d, gps.gprmc.lon = %d\\r\\n&quot;,gps.gprmc.lat,gps.gprmc.lon); NRF_LOG_INFO(&quot;res = %d\\r\\n&quot;,ret_sscanf); if (ret_sscanf &gt; 8) &#123; ret = true; gps.report_data.gps_info.lat = (int)(gps.gprmc.lat/100) + (gps.gprmc.lat/100.0 - (int)(gps.gprmc.lat/100)) *100.0 / 60.0;//转换成dd.ddddd gps.report_data.gps_info.lon = (int)(gps.gprmc.lon/100) + (gps.gprmc.lon/100.0 - (int)(gps.gprmc.lon/100)) *100.0 / 60.0;//转换成dd.ddddd NRF_LOG_INFO(&quot;gps.report_data.lat = %d, gps.report_data.lon = %d\\r\\n&quot;,gps.report_data.gps_info.lat,gps.report_data.gps_info.lon); GPS_POWER_OFF; gps_parse_count = 0; &#125; &#125; &#125; return ret; &#125; GPS校验函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* hb：高位 lb：低位*/uint8_t AsciiToHexVal(uint8_t h_b,uint8_t l_b)&#123; uint8_t hex_val; if((h_b &gt;= &#x27;0&#x27;)&amp;&amp;(h_b &lt;= &#x27;9&#x27;)) &#123; hex_val = h_b - &#x27;0&#x27;; &#125; else if((h_b &gt;= &#x27;A&#x27;)&amp;&amp;(h_b &lt;= &#x27;F&#x27;)) &#123; hex_val = h_b - &#x27;A&#x27; + 10; &#125; else if((h_b &gt;= &#x27;a&#x27;)&amp;&amp;(h_b &lt;= &#x27;f&#x27;)) &#123; hex_val = h_b - &#x27;a&#x27; + 10; &#125; hex_val &lt;&lt;= 4; if((l_b &gt;= &#x27;0&#x27;)&amp;&amp;(l_b &lt;= &#x27;9&#x27;)) &#123; hex_val |= l_b - &#x27;0&#x27;; &#125; else if((l_b &gt;= &#x27;A&#x27;)&amp;&amp;(l_b &lt;= &#x27;F&#x27;)) &#123; hex_val |= l_b - &#x27;A&#x27; + 10; &#125; else if((l_b &gt;= &#x27;a&#x27;)&amp;&amp;(l_b &lt;= &#x27;f&#x27;)) &#123; hex_val |= l_b - &#x27;a&#x27; + 10; &#125; return hex_val;&#125;uint8_t GpsFrameCheck(char *gps_data, uint8_t len)&#123; uint8_t i,res = false; uint8_t gps_check = 0,cal_check =0; for(i=1;i&lt;len-3;i++) &#123; cal_check ^= gps_data[i]; &#125; gps_check = AsciiToHexVal(gps_data[len-2],gps_data[len-1]); if(gps_check == cal_check) &#123; NRF_LOG_INFO(&quot;gps_check == cal_check\\r\\n&quot;,gps_check); res = true; &#125; return res;&#125;","categories":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/categories/C-Lib/"}],"tags":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/tags/C-Lib/"}]},{"title":"个人提升计划","slug":"plan","date":"2020-12-22T12:11:41.963Z","updated":"2020-12-28T11:34:21.951Z","comments":true,"path":"2020/12/22/plan/","link":"","permalink":"https://github.com/eagle230/nate.github.io/2020/12/22/plan/","excerpt":"","text":"计划1.整理和编写开源代码库目标：方便以后开发移植，帮助自己深入理解实现原理和提高代码编程能力。 ring buffer 【环形缓冲区】 AT指令【AT发送和解析框架】 GPS Parser【GPS解析库】 log通用打印【方便移植、可设置log等级、可类实现shell功能的通用库】 裸机多任务系统【方便移植，基于链表】 BOOT+OTA框架【通用性强，方便移植，安全可靠】","categories":[{"name":"plan","slug":"plan","permalink":"https://github.com/eagle230/nate.github.io/categories/plan/"}],"tags":[{"name":"plan","slug":"plan","permalink":"https://github.com/eagle230/nate.github.io/tags/plan/"}]},{"title":"Githuh Pages + Hexo 搭建个人博客","slug":"Githuh Pages + Hexo","date":"2020-12-22T12:11:41.962Z","updated":"2020-12-28T09:29:13.823Z","comments":true,"path":"2020/12/22/Githuh Pages + Hexo/","link":"","permalink":"https://github.com/eagle230/nate.github.io/2020/12/22/Githuh%20Pages%20+%20Hexo/","excerpt":"","text":"Githuh Pages + Hexo 搭建个人博客本地git配置配置本地git的用户信息12git config --global user.name &quot;Nate&quot; git config --global user.email &quot;287770626@qq.com&quot; 生成ssh密钥文件1ssh-keygen -t rsa -C &quot;287770626@qq.com&quot; 期间会让你选择保存的目录，推荐使默认文件名，那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码），当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了。所以就是三个回车即可。 配置github的ssh找到本地用户里面的id_rsa.pub，打开并且在Github Seting里面设置好ssh。 测试git与github关联情况执行命令：ssh -T &#103;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#x6d; 创建github pages 仓库创建一个github page仓库，名字格式必须为 1username.github.io 克隆仓库到本地1git clone git@github.com:eagle230&#x2F;nate.github.io.git 安装Hexo和Nodejs安装Node.js1、Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)2、Git 安装Hexo1.新建个blog目录，在此处执行cmd， 1npm i hexo-cli -g 开始安装hexo2.输入npm install安装必备的组件3.hexo g 生成静态4.hexo s 开启服务5.打开http://localhost:40006.新建一篇博客，在cmd执行命令： 1hexo new post “hello world” 7.在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 8.编辑根目录下_config.yml文件 1234deploy: type: git repo: git@github.com:linton6&#x2F;linton.github.io.git # 填写自己的仓库地址 branch: master 9.加载博客样式文件 (搭建的时候遇到的坑) 需要修改_config.yml文件中的url地址和根目录 12url：是github Page给我们分配的网址root：是搭建该博客的仓库名 10.更改主题github下载好主题XXX后放在themes目录下，然后编辑站点的_config.yml中的theme: XXX11.更改网页图标（更改完整路径，遇到的坑） 1git clone git@github.com:cofess&#x2F;hexo-theme-pure.git themes&#x2F;pure 更改主题中 1favicon: https:&#x2F;&#x2F;eagle230.github.io&#x2F;nate.github.io&#x2F;favicon.png 12.hexo g ，生成新的静态网页文件。13.执行hexo d 上传到github上。14.打开https://eagle230.github.io/nate.github.io/就看到了网页。 写博客直接在port文件里面添加md格式的文件即可。 123456789---title: 个人能力提升计划categories: - plan # 分类tags: - plan # 标签# toc: true # 是否启用内容索引comments: true # 是否开启评论功能--- 参考链接： []: https://blog.csdn.net/linton1/article/details/90137367","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/eagle230/nate.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/eagle230/nate.github.io/tags/Hexo/"}]}],"categories":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/categories/C-Lib/"},{"name":"plan","slug":"plan","permalink":"https://github.com/eagle230/nate.github.io/categories/plan/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/eagle230/nate.github.io/categories/Hexo/"}],"tags":[{"name":"C Lib","slug":"C-Lib","permalink":"https://github.com/eagle230/nate.github.io/tags/C-Lib/"},{"name":"plan","slug":"plan","permalink":"https://github.com/eagle230/nate.github.io/tags/plan/"},{"name":"Hexo","slug":"Hexo","permalink":"https://github.com/eagle230/nate.github.io/tags/Hexo/"}]}